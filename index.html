<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xmas Photo Cloud | Gesture Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020202; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #video-input { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
                       z-index: 5; transform: scaleX(-1); border-radius: 8px; opacity: 0.6; border: 1px solid #d4af37; }
        #ui { position: absolute; top: 30px; left: 30px; z-index: 10; color: #d4af37; pointer-events: none; }
        .btn { pointer-events: auto; background: rgba(212,175,55,0.2); border: 1px solid #d4af37; 
               color: #d4af37; padding: 10px 20px; cursor: pointer; margin-top: 10px; display: inline-block; }
        .btn:hover { background: #d4af37; color: black; }
        #loader { position: fixed; inset: 0; background: black; z-index: 100; display: flex; 
                  justify-content: center; align-items: center; color: #d4af37; letter-spacing: 4px; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

<div id="loader">INITIALIZING SYSTEM...</div>
<div id="ui">
    <h1 style="margin:0; font-weight: 200;">NOEL GESTURE v2.0</h1>
    <p id="status">Waiting for Camera...</p>
    <label class="btn">
        UPLOAD PHOTOS
        <input type="file" id="upload" multiple accept="image/*" style="display:none">
    </label>
</div>
<video id="video-input"></video>
<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- 初始化场景 ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020202, 0.015);
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 后期处理 ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.1);
    composer.addPass(bloom);

    // --- 灯光 ---
    const light1 = new THREE.PointLight(0xffd700, 2, 100);
    light1.position.set(10, 10, 10);
    scene.add(light1);
    scene.add(new THREE.AmbientLight(0xffffff, 0.1));

    // --- 粒子系统 ---
    const count = 1200;
    const geometry = new THREE.IcosahedronGeometry(0.2, 0);
    const material = new THREE.MeshStandardMaterial({ color: 0x1a3c20, metalness: 0.7, roughness: 0.2 });
    const iMesh = new THREE.InstancedMesh(geometry, material, count);
    scene.add(iMesh);

    const dummy = new THREE.Object3D();
    const pData = [];
    for(let i=0; i<count; i++) {
        const y = Math.random() * 30 - 15;
        const r = 10 * (1 - (y + 15)/30);
        const a = y * 0.5 + Math.random() * Math.PI * 2;
        const treePos = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
        const scatterPos = new THREE.Vector3().randomDirection().multiplyScalar(30 + Math.random()*20);
        
        pData.push({ curr: treePos.clone(), tree: treePos, scat: scatterPos, speed: 0.02 + Math.random()*0.05 });
        
        // 随机给粒子点颜色
        if(Math.random() > 0.8) iMesh.setColorAt(i, new THREE.Color(0xffd700));
        else if(Math.random() > 0.9) iMesh.setColorAt(i, new THREE.Color(0xc41e3a));
    }

    // --- 照片系统 ---
    const photos = [];
    function addPhoto(texture, imgElement) {
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(mat);
        
        // 修复报错的关键：直接从 HTML Image 元素拿宽高比
        const aspect = imgElement.height / imgElement.width;
        sprite.scale.set(5, 5 * aspect, 1);
        
        const y = Math.random() * 20 - 10;
        const r = 8 * (1 - (y + 15)/30) + 2;
        const a = Math.random() * Math.PI * 2;
        sprite.position.set(Math.cos(a)*r, y, Math.sin(a)*r);
        
        scene.add(sprite);
        photos.push({ mesh: sprite, tree: sprite.position.clone(), scat: new THREE.Vector3().randomDirection().multiplyScalar(20) });
    }

    // --- 手势状态 ---
    const STATE = { mode: 'TREE', hand: false, x: 0, camAngle: 0 };

    // --- MediaPipe 配置 ---
    const video = document.getElementById('video-input');
    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.onResults(res => {
        document.getElementById('loader').style.display = 'none';
        if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            STATE.hand = true;
            const lm = res.multiHandLandmarks[0];
            const open = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
            const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            
            STATE.x = (lm[0].x - 0.5) * 2;
            if(pinch < 0.05) STATE.mode = 'PHOTO';
            else if(open > 0.35) STATE.mode = 'SCATTER';
            else STATE.mode = 'TREE';
            
            document.getElementById('status').innerText = `MODE: ${STATE.mode}`;
        } else {
            STATE.hand = false;
        }
    });

    const cam = new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 320, height: 240 });
    cam.start();

    // --- 上传逻辑 ---
    document.getElementById('upload').addEventListener('change', (e) => {
        const files = e.target.files;
        for(let f of files) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => {
                    const tex = new THREE.Texture(img);
                    tex.needsUpdate = true;
                    addPhoto(tex, img); // 传入加载好的 img 元素
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(f);
        }
    });

    // --- 渲染循环 ---
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now() * 0.001;

        // 相机旋转
        const targetAngle = STATE.hand ? STATE.x * 2 : time * 0.2;
        STATE.camAngle += (targetAngle - STATE.camAngle) * 0.05;
        camera.position.set(Math.sin(STATE.camAngle)*50, 10, Math.cos(STATE.camAngle)*50);
        camera.lookAt(0, 0, 0);

        // 粒子更新
        pData.forEach((p, i) => {
            const target = (STATE.mode === 'TREE') ? p.tree : p.scat;
            p.curr.lerp(target, p.speed);
            dummy.position.copy(p.curr);
            dummy.updateMatrix();
            iMesh.setMatrixAt(i, dummy.matrix);
        });
        iMesh.instanceMatrix.needsUpdate = true;

        // 照片更新
        photos.forEach(p => {
            let target;
            if(STATE.mode === 'PHOTO') {
                target = camera.position.clone().lerp(new THREE.Vector3(0,0,0), 0.6);
                p.mesh.lookAt(camera.position);
            } else if(STATE.mode === 'SCATTER') {
                target = p.scat;
            } else {
                target = p.tree;
                p.mesh.lookAt(camera.position);
            }
            p.mesh.position.lerp(target, 0.05);
        });

        composer.render();
    }
    animate();

    window.onresize = () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    };
</script>
</body>
</html>
