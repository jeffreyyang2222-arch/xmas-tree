<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Luxe Xmas - Ultimate Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        :root { --gold: #fceea7; --deep-gold: #d4af37; --glow: rgba(212, 175, 55, 0.6); }
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Times New Roman', serif; }

        /* Loading Screen */
        #loader { position: fixed; inset: 0; background: radial-gradient(circle at center, #1a1a1a, #000); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.8s ease; }
        .spinner { width: 60px; height: 60px; border: 2px solid rgba(212, 175, 55, 0.1); border-top: 2px solid var(--deep-gold); border-radius: 50%; animation: spin 1s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite; box-shadow: 0 0 20px var(--glow); }

        /* UI */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; transition: opacity 0.5s ease; }
        h1 { font-family: 'Cinzel', serif; font-size: clamp(30px, 5vw, 70px); margin-top: 5vh; background: linear-gradient(135deg, #fff 0%, var(--deep-gold) 40%, #fceea7 60%, #fff 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px var(--glow)); letter-spacing: 0.2em; text-align: center; }

        .controls { position: absolute; bottom: 40px; pointer-events: auto; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .btn-upload { padding: 12px 35px; border: 1px solid var(--deep-gold); color: var(--gold); background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); cursor: pointer; letter-spacing: 2px; font-family: 'Cinzel', serif; font-size: 14px; transition: 0.4s; clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%); }
        .btn-upload:hover { background: var(--deep-gold); color: #000; box-shadow: 0 0 30px var(--glow); transform: translateY(-2px); }

        .status-box { font-family: monospace; font-size: 10px; color: rgba(255,255,255,0.5); border-left: 2px solid var(--deep-gold); padding-left: 10px; text-align: left; width: 200px; }
        .status-active { color: var(--gold); text-shadow: 0 0 10px var(--deep-gold); }

        #webcam-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border: 1px solid var(--deep-gold); border-radius: 4px; overflow: hidden; opacity: 0.7; transition: opacity 0.3s; transform: scaleX(-1); }
        #webcam-container:hover { opacity: 1; }
        video { width: 100%; height: 100%; object-fit: cover; }

        @keyframes spin { to { transform: rotate(360deg); } }
        .ui-hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <p style="color:var(--deep-gold); letter-spacing:4px; margin-top:20px; font-size: 12px;">CONJURING LUXURY</p>
</div>

<div id="ui-layer">
    <h1>MERRY CHRISTMAS TLT</h1>
    <div class="controls">
        <div class="status-box">
            <div>MODE: <span id="mode-text" class="status-active">TREE</span></div>
            <div style="margin-top:4px;">HAND: <span id="hand-text">DETECTING...</span></div>
        </div>
        <button class="btn-upload" onclick="document.getElementById('file-input').click()">UPLOAD MEMORIES</button>
        <input type="file" id="file-input" hidden accept="image/*" multiple>
    </div>
</div>

<div id="webcam-container"><video id="video" playsinline autoplay muted></video></div>

<!-- Import Maps -->
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // 配置参数
    const CONFIG = {
        particleCount: 4000, // 粒子数量大幅增加
        dustCount: 1500,     // 背景金粉数量
        goldColor: 0xffd700,
        silverColor: 0xffffff,
        gestureSmooth: 5     // 手势防抖帧数
    };

    const STATE = {
        mode: 'TREE', // TREE, SCATTER, FOCUS
        targetRot: {x:0, y:0},
        curRot: {x:0, y:0},
        gestureBuffer: [], // 用于平滑手势
        time: 0
    };

    let scene, camera, renderer, composer;
    let mainGroup, instancedMeshGold, instancedMeshSilver, dustSystem;
    let handLandmarker, video;
    let particlesData = []; // 存储每个粒子的位置信息
    let photoObjects = [];  // 存储上传的照片对象
    const dummy = new THREE.Object3D(); // 用于矩阵计算的辅助对象

    // 初始化
    async function init() {
        // 渲染器设置
        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // 增加景深感

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 2, 45);

        // 主容器
        mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // 后期处理 (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.8; // 更强的光晕
        bloomPass.radius = 0.5;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 环境贴图 - 关键在于金属反射
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator        .fromScene(new RoomEnvironment(), 0.04).texture;

        // 灯光系统：营造舞台感
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffd700, 1000);
        spotLight.position.set(10, 50, 20);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 1;
        spotLight.castShadow = true;
        scene.add(spotLight);

        const pointLight = new THREE.PointLight(0xffaa00, 100, 50);
        pointLight.position.set(0, 0, 10);
        scene.add(pointLight);

        // 创建核心视觉元素
        createParticles();
        createDust();

        // 启动CV和事件
        await setupCV();
        setupEvents();

        // 移除加载页
        const loader = document.getElementById('loader');
        loader.style.opacity = '0';
        setTimeout(() => loader.remove(), 800);

        animate();
    }

    // --- 核心：高性能粒子系统 (InstancedMesh) ---
    function createParticles() {
        // 1. 材质：极致奢华的物理金属感
        const goldMat = new THREE.MeshPhysicalMaterial({
            color: CONFIG.goldColor, metalness: 1.0, roughness: 0.15,
            clearcoat: 1.0, clearcoatRoughness: 0.1,
            emissive: 0x332200, emissiveIntensity: 0.2
        });

        const silverMat = new THREE.MeshPhysicalMaterial({
            color: CONFIG.silverColor, metalness: 0.9, roughness: 0.2,
            clearcoat: 0.8
        });

        // 2. 几何体：钻石形状
        const geometry = new THREE.IcosahedronGeometry(0.2, 0);

        // 3. 创建实例化网格
        const halfCount = Math.floor(CONFIG.particleCount / 2);
        instancedMeshGold = new THREE.InstancedMesh(geometry, goldMat, halfCount);
        instancedMeshSilver = new THREE.InstancedMesh(geometry, silverMat, halfCount);

        mainGroup.add(instancedMeshGold);
        mainGroup.add(instancedMeshSilver);

        // 4. 初始化数据
        const initParticle = (index, isGold) => {
            const i = isGold ? index : index + halfCount;

            // 圣诞树形态计算 (螺旋上升)
            const t = index / halfCount; // 0 to 1
            const spiralAngle = t * Math.PI * 30; // 圈数
            const height = t * 30 - 15;
            const radius = (1 - t) * 12 + 0.5; // 底部宽，顶部尖

            const treePos = new THREE.Vector3(
                Math.cos(spiralAngle) * radius + (Math.random()-0.5),
                height,
                Math.sin(spiralAngle) * radius + (Math.random()-0.5)
            );

            // 散开形态计算 (球形爆炸)
            const scatterPos = new THREE.Vector3().randomDirection().multiplyScalar(15 + Math.random() * 20);

            // 存入数据
            particlesData.push({
                currentPos: scatterPos.clone(), // 初始位置
                treePos: treePos,
                scatterPos: scatterPos,
                speed: 0.02 + Math.random() * 0.04,
                phase: Math.random() * Math.PI * 2,
                rotationSpeed: { x: Math.random()*0.1, y: Math.random()*0.1 }
            });

            // 初始化矩阵
            dummy.position.copy(scatterPos);
            dummy.updateMatrix();
            if(isGold) instancedMeshGold.setMatrixAt(index, dummy.matrix);
            else instancedMeshSilver.setMatrixAt(index, dummy.matrix);
        };

        for (let i = 0; i < halfCount; i++) {
            initParticle(i, true);  // 金色
            initParticle(i, false); // 银色
        }
    }

    // --- 背景氛围：漂浮金粉 ---
    function createDust() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        for(let i=0; i<CONFIG.dustCount; i++) {
            positions.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*50);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
            color: 0xffd700, size: 0.15, transparent: true, opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        dustSystem = new THREE.Points(geometry, material);
        scene.add(dustSystem);
    }

    // --- 视觉识别 (CV) 设置 ---
    async function setupCV() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
            runningMode: "VIDEO",
            numHands: 1
        });

        video = document.getElementById('video');
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;

        return new Promise(resolve => {
            video.onloadeddata = () => { video.play(); resolve(); }
        });
    }

    // --- 智能手势判定逻辑 ---
    function detectGesture(landmarks) {
        if (!landmarks || landmarks.length === 0) return null;

        const lm = landmarks[0];

        // 关键点索引:
        // 拇指: 4, 食指: 8, 中指: 12, 无名指: 16, 小指: 20
        // 掌根: 0

        // 1. 计算手指是否伸直 (指尖y < 指关节y) 注意：视频坐标系y向下增大，所以数值越小越靠上
        const isFingerOpen = (tip, pip) => lm[tip].y < lm[pip].y;

        const indexOpen = isFingerOpen(8, 6);
        const middleOpen = isFingerOpen(12, 10);
        const ringOpen = isFingerOpen(16, 14);
        const pinkyOpen = isFingerOpen(20, 18);

        // 2. 捏合判定 (拇指尖与食指尖距离)
        const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

        // 3. 状态机逻辑
        if (pinchDist < 0.05) return 'FOCUS'; // 捏合 -> 聚焦/展示照片
        if (indexOpen && middleOpen && ringOpen && pinkyOpen) return 'SCATTER'; // 全张开 -> 爆炸
        if (!indexOpen && !middleOpen && !ringOpen && !pinkyOpen) return 'TREE'; // 全握拳 -> 聚合

        return STATE.mode; // 保持现状
    }

    // --- 动画循环 ---
    function animate() {
        requestAnimationFrame(animate);
        STATE.time += 0.01;

        // 1. CV 处理与手势防抖
        if (video.readyState >= 2 && handLandmarker) {
            const results = handLandmarker.detectForVideo(video, performance.now());

            if (results.landmarks.length > 0) {
                // 旋转控制
                const palm = results.landmarks[0][9];
                STATE.targetRot.y = (palm.x - 0.5) * 3;
                STATE.targetRot.x = (palm.y - 0.5) * 2;

                // 手势识别
                const rawGesture = detectGesture(results.landmarks);
                if (rawGesture) {
                    STATE.gestureBuffer.push(rawGesture);
                    if (STATE.gestureBuffer.length > CONFIG.gestureSmooth) STATE.gestureBuffer.shift();

                    // 投票机制：只有当缓冲区大部分帧一致时才切换
                    const counts = STATE.gestureBuffer.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
                    const winner = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);

                    if (counts[winner] > CONFIG.gestureSmooth * 0.6) {
                        STATE.mode = winner;
                        updateUI(winner);
                    }
                }
                document.getElementById('hand-text').innerText = "TRACKING";
                document.getElementById('hand-text').style.color = "#0f0";
            } else {
                document.getElementById('hand-text').innerText = "LOST SIGNAL";
                document.getElementById('hand-text').style.color = "red";
                // 失去手势时自动慢旋转
                STATE.targetRot.y += 0.005;
            }
        }

        // 2. 场景平滑旋转
        STATE.curRot.x = THREE.MathUtils.lerp(STATE.curRot.x, STATE.targetRot.x, 0.05);
        STATE.curRot.y = THREE.MathUtils.lerp(STATE.curRot.y, STATE.targetRot.y, 0.05);
        mainGroup.rotation.set(STATE.curRot.x, STATE.curRot.y, 0);

        // 3. 粒子动画 (Heavy Lifting)
        const halfCount = Math.floor(CONFIG.particleCount / 2);

        // 确定目标位置
        let targetType = 'treePos';
        if (STATE.mode === 'SCATTER') targetType = 'scatterPos';
        // FOCUS模式下，粒子稍微散开一点作为背景
        if (STATE.mode === 'FOCUS') targetType = 'treePos';

        for (let i = 0; i < particlesData.length; i++) {
            const data = particlesData[i];
            const isGold = i < halfCount;
            const instanceIdx = isGold ? i : i - halfCount;

            // 目标位置计算
            let target = data[targetType];

            // 如果是FOCUS模式，让粒子稍微膨胀，给照片腾出空间
            if (STATE.mode === 'FOCUS') {
                target = data.treePos.clone().multiplyScalar(1.5);
            }

            // 插值移动
            data.currentPos.lerp(target, data.speed * (STATE.mode === 'SCATTER' ? 2 : 1));

            // 呼吸效果 (Scale)
            const scale =             1 + Math.sin(STATE.time * 3 + data.phase) * 0.4; // 呼吸闪烁算法

            dummy.position.copy(data.currentPos);

            // 粒子自转动画：让每个钻石都在旋转
            dummy.rotation.x += data.rotationSpeed.x;
            dummy.rotation.y += data.rotationSpeed.y;

            dummy.scale.setScalar(scale);
            dummy.updateMatrix();

            // 根据索引更新对应的 InstancedMesh
            if (isGold) instancedMeshGold.setMatrixAt(instanceIdx, dummy.matrix);
            else instancedMeshSilver.setMatrixAt(instanceIdx, dummy.matrix);
        }

        // 必须标记更新，GPU才会渲染新位置
        instancedMeshGold.instanceMatrix.needsUpdate = true;
        instancedMeshSilver.instanceMatrix.needsUpdate = true;

        // 4. 背景金粉漂浮动画
        if(dustSystem) {
            dustSystem.rotation.y = STATE.time * 0.02; // 缓慢旋转背景
            dustSystem.position.y = Math.sin(STATE.time * 0.2) * 2; // 上下浮动
        }

        // 5. 照片墙逻辑 (Focus Mode)
        updatePhotos();

        composer.render();
    }

    // --- 照片管理系统 ---
    function updatePhotos() {
        if (photoObjects.length === 0) return;

        photoObjects.forEach((photo, i) => {
            if (STATE.mode === 'FOCUS') {
                // 螺旋排列展示照片
                const angle = i * 0.8 + STATE.time * 0.3;
                const radius = 7;
                const targetPos = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.sin(i * 0.5 + STATE.time * 0.5) * 3, // 上下浮动
                    Math.sin(angle) * radius + 5
                );

                photo.position.lerp(targetPos, 0.05);
                photo.lookAt(camera.position); // 始终面向镜头
                photo.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
            } else {
                // 非Focus模式下，照片缩小并隐藏到中心
                photo.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                photo.position.lerp(new THREE.Vector3(0,0,0), 0.1);
            }
        });
    }

    // --- UI 状态更新 ---
    function updateUI(mode) {
        const el = document.getElementById('mode-text');
        el.innerText = mode;

        // 根据模式改变UI颜色
        if(mode === 'FOCUS') {
            el.style.color = '#fff';
            el.style.textShadow = '0 0 10px #fff';
        } else if(mode === 'SCATTER') {
            el.style.color = '#ffaa00';
            el.style.textShadow = '0 0 15px #ff0000';
        } else {
            el.style.color = CONFIG.goldColor;
            el.style.textShadow = '0 0 10px var(--deep-gold)';
        }
    }

    // --- 事件监听 ---
    function setupEvents() {
        // 窗口大小调整适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // 文件上传处理
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        tex.needsUpdate = true;

                        // 创建相框几何体
                        const aspect = img.height / img.width;
                        const geo = new THREE.PlaneGeometry(3, 3 * aspect);
                        const mat = new THREE.MeshBasicMaterial({
                            map: tex,
                            side: THREE.DoubleSide,
                            transparent: true
                        });
                        const mesh = new THREE.Mesh(geo, mat);

                        // 添加金色边框
                        const borderGeo = new THREE.EdgesGeometry(geo);
                        const borderMat = new THREE.LineBasicMaterial({ color: 0xffd700, linewidth: 2 });
                        const border = new THREE.LineSegments(borderGeo, borderMat);
                        mesh.add(border);

                        mesh.scale.set(0,0,0); // 初始状态隐藏
                        mainGroup.add(mesh);
                        photoObjects.push(mesh);

                        // 上传后自动切换到展示模式
                        STATE.mode = 'FOCUS';
                        updateUI('FOCUS');
                    };
                };
                reader.readAsDataURL(file);
            });
        });
    }

    // 启动程序
    init();
</script>
</body>
</html>


