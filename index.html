<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Luxe Xmas - Creative Tech</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        :root { --gold: #fceea7; --deep-gold: #d4af37; --glow: rgba(212, 175, 55, 0.6); }
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Times New Roman', serif; }
        #loader { position: fixed; inset: 0; background: #000; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.8s ease; }
        .spinner { width: 50px; height: 50px; border: 1px solid transparent; border-top: 2px solid var(--deep-gold); border-radius: 50%; animation: spin 1s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; transition: opacity 0.5s ease; }
        h1 { font-family: 'Cinzel', serif; font-size: 64px; margin-top: 40px; background: linear-gradient(135deg, #fff 0%, var(--deep-gold) 50%, #fff 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px var(--glow)); letter-spacing: 8px; }
        .upload-wrapper { position: absolute; bottom: 60px; pointer-events: auto; display: flex; flex-direction: column; align-items: center; }
        .btn-upload { padding: 15px 40px; border: 1px solid var(--deep-gold); color: #fff; background: rgba(0,0,0,0.5); backdrop-filter: blur(15px); cursor: pointer; letter-spacing: 3px; font-weight: bold; border-radius: 2px; box-shadow: 0 0 20px rgba(212, 175, 55, 0.2); transition: 0.4s; }
        .btn-upload:hover { background: var(--deep-gold); color: #000; box-shadow: 0 0 40px var(--glow); }
        #webcam-container { position: absolute; bottom: 10px; right: 10px; opacity: 0; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .ui-hidden { opacity: 0; }
    </style>
</head>
<body>

<div id="loader"><div class="spinner"></div><p style="color:var(--deep-gold); letter-spacing:5px;">AWAKENING GOLDEN SPIRIT</p></div>
<div id="ui-layer">
    <h1>MERRY XMAS</h1>
    <div class="upload-wrapper">
        <button class="btn-upload" onclick="document.getElementById('file-input').click()">UPLOAD MEMORIES</button>
        <input type="file" id="file-input" hidden accept="image/*" multiple>
        <div style="color:rgba(255,255,255,0.4); font-size:10px; margin-top:15px;">GESTURE: FIST (TREE) | OPEN (SCATTER) | PINCH (ZOOM)</div>
    </div>
</div>
<div id="webcam-container"><video id="video" playsinline></video></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    const STATE = { mode: 'TREE', elements: [], targetRot: {x:0, y:0}, curRot: {x:0, y:0}, focusObj: null };

    let scene, camera, renderer, composer, mainGroup, handLandmarker, video;

    async function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.5; // 增加曝光让金色更耀眼
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 5, 50);

        mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // 后期：强化辉光效果
        const composer_ = new EffectComposer(renderer);
        composer_.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.5, 0.85);
        composer_.addPass(bloom);
        composer = composer_;

        // 环境反射：打造金属感的关键
        const envGen = new THREE.PMREMGenerator(renderer);
        scene.environment = envGen.fromScene(new RoomEnvironment(), 0.04).texture;

        // 灯光
        const sun = new THREE.DirectionalLight(0xffffff, 3);
        sun.position.set(10, 20, 10);
        scene.add(sun);
        const spot = new THREE.SpotLight(0xd4af37, 2000, 100, 0.5, 1);
        spot.position.set(0, 40, 0);
        scene.add(spot);

        createElements();
        await setupCV();
        setupEvents();

        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').remove(), 800);
        animate();
    }

    function createElements() {
        // 奢华物理材质
        const goldMat = new THREE.MeshPhysicalMaterial({
            color: 0xd4af37, metalness: 1.0, roughness: 0.1,
            emissive: 0x443300, emissiveIntensity: 0.5,
            clearcoat: 1.0, clearcoatRoughness: 0.1
        });
        const silverMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 1.0, roughness: 0.05,
            emissive: 0x222222, emissiveIntensity: 0.2
        });

        // 主粒子：圣诞球与方块
        const geometries = [new THREE.IcosahedronGeometry(0.3, 0), new THREE.BoxGeometry(0.3, 0.3, 0.3)];

        for(let i = 0; i < 1500; i++) {
            const geo = geometries[Math.floor(Math.random() * geometries.length)];
            const mat = Math.random() > 0.2 ? goldMat : silverMat;
            const mesh = new THREE.Mesh(geo, mat);

            mainGroup.add(mesh);
            STATE.elements.push(new Particle(mesh, 'DECO'));
        }
    }

    class Particle {
        constructor(mesh, type) {
            this.mesh = mesh;
            this.type = type;
            this.phase = Math.random() * Math.PI * 2;
            this.speed = 0.5 + Math.random();

            // 圣诞树分布逻辑 (更加紧密的螺旋)
            const t = Math.random();
            const radius = 10 * (1 - t);
            const angle = t * Math.PI * 45;
            this.treePos = new THREE.Vector3(
                Math.cos(angle) * radius,
                t * 26 - 13,
                Math.sin(angle) * radius
            );

            this.scatterPos = new THREE.Vector3().setFromSphericalCoords(
                12 + Math.random() * 15, Math.random() * Math.PI, Math.random() * Math.PI * 2
            );
        }

        update(time) {
            let target = (STATE.mode === 'TREE') ? this.treePos : this.scatterPos;

            // 核心：炫彩闪烁效果
            const scaleBase = (STATE.mode === 'FOCUS' && STATE.focusObj !== this) ? 0.2 : 1;
            const blink = Math.sin(time * 5 * this.speed + this.phase) * 0.3 + 0.7;
            this.mesh.scale.setScalar(THREE.MathUtils.lerp(this.mesh.scale.x, scaleBase * blink, 0.1));

            if (STATE.mode === 'FOCUS' && this === STATE.focusObj) {
                this.mesh.position.lerp(new THREE.Vector3(0, 0, 32), 0.1);
                this.mesh.scale.setScalar(4);
            } else {
                this.mesh.position.lerp(target, 0.05);
            }

            this.mesh.rotation.x += 0.01 * this.speed;
            this.mesh.rotation.y += 0.015 * this.speed;
        }
    }

    async function setupCV() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
            runningMode: "VIDEO"
        });
        video = document.getElementById('video');
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.play();
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now() * 0.001;

        if (video.readyState >= 2) {
            const results = handLandmarker.detectForVideo(video, performance.now());
            if (results.landmarks?.length > 0) {
                const marks = results.landmarks[0];
                // 逻辑判定
                const dist = Math.hypot(marks[4].x - marks[8].x, marks[4].y - marks[8].y);
                const open = marks[12].y < marks[9].y;

                if (dist < 0.04) STATE.mode = 'FOCUS';
                else if (open) STATE.mode = 'SCATTER';
                else STATE.mode = 'TREE';

                STATE.targetRot.y = (marks[9].x - 0.5) * 2.5;
                STATE.targetRot.x = (marks[9].y - 0.5) * 1.5;
            }
        }

        STATE.curRot.x = THREE.MathUtils.lerp(STATE.curRot.x, STATE.targetRot.x, 0.05);
        STATE.curRot.y = THREE.MathUtils.lerp(STATE.curRot.y, STATE.targetRot.y, 0.05);
        mainGroup.rotation.set(STATE.curRot.x, STATE.curRot.y + time * 0.2, 0);

        STATE.elements.forEach(el => el.update(time));
        composer.render();
    }

    function setupEvents() {
        window.addEventListener('keydown', e => e.key === 'h' && document.getElementById('ui-layer').classList.toggle('ui-hidden'));
        document.getElementById('file-input').addEventListener('change', e => {
            for(let f of e.target.files) {
                const r = new FileReader();
                r.onload = ev => {
                    new THREE.TextureLoader().load(ev.target.result, t => {
                        t.colorSpace = THREE.SRGBColorSpace;
                        const g = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({map:t, side:2}));
                        mainGroup.add(g);
                        const p = new Particle(g, 'PHOTO');
                        STATE.elements.push(p);
                        STATE.focusObj = p;
                    });
                };
                r.readAsDataURL(f);
            }
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    init();
</script>
</body>
</html>
